# Тестовое задание на вакансию django-разработчика

## Python

1. Что такое `lambda` функция, синтаксис вызова, привести пример случаев использования.
2. Контекстные менеджеры, для чего используются. Привести пример вызова множественных менеджеров для одного контекста в `python 3.10+`. Привести пример описания class-based контекстного менеджера.
3. Как реализованы модификаторы доступности `public`, `private`, `protected` в классах `python 3.10+`.
4. Что такое декораторы? Для чего используются декораторы `@staticmethod`, `@classmethod` при описании классов `python 3.10+`.
5. Изменить функцию `intersection`, которая принимает списки целых чисел `lists`, чтобы она возвращала пересечение между ними, отсортированное по возрастанию. Если пересечения нет — функция возвращает пустой список.
```python
from collections.abc import Iterable


def intersection(*lists: Iterable[int]) -> list[int]:
    # <код функции>
    ...


# Тестовые кейсы
test = [
    [1, 2, 3],
    [3, 4, 5],
    [3],
    [3, 8, 10, 400]
]

assert intersection(*test) == [3]

test = [
    range(-50, 50),
    range(-100, 100, 2),
    range(-1000, 1000, 8),
]

assert intersection(*test) == [-48, -40, -32, -24, -16, -8, 0, 8, 16, 24, 32, 40, 48]

test = [
    [1, 2, 3],
    [1, 2, 3],
    [],
]

assert intersection(*test) == []

test = [
    [1, 1, 1, 1, 0, 1, 1, 1, 1],
    [0, 0, 0, 0, 1, 0, 0, 0, 0],
    [1, 0],
]

assert intersection(*test) == [0, 1]

```
6. Из строки `path`, которая является __абсолютным путем__ (начинающимся со слеша `/`) к файлу или папке в UNIX-подобной файловой системе, получить упрощенный __канонический путь__.

    В UNIX-подобной файловой системе, точка — `.` — означает текущую папку, а двойные точки — `..` — папка на один уровень выше. Последовательные слэши (например `//`) должны восприниматься как одиночный слеш `/`. В рамках этой задачи, любые иные использования нескольких точек, например `...` должны восприниматься как название папки / файла.

    __Канонический путь__ должен быть следующего формата:
    * Путь начинается с одиночного слэша `/`
    * Любые две папки разделены одиночным слэшем `/`
    * Путь не должен заканчиваться слэшем `/`
    * Путь содержит только папки от корневой папки до целевого файла / папки (то есть в нем не должны применяться точки `.` и двойные точки `..`)
        
    Задание — отредактировать метод `simplifyPath` класса `Solution`, чтобы он, принимая __абсолютный путь__ возвращал __канонический путь__. 

```python
class Solution:
    def simplifyPath(self, path: str) -> str:
        # <код функции>
```

> Пример 1:
```text
Ввод: path = "/home/"
Выход: "/home"
Объяснение: Обратить внимание, что в ответе отсутствует слэш после наименования последней папки.
```
> Пример 2:
```text
Ввод: path = "/../"
Выход: "/"
Объяснение: Переход на один уровень вверх от корневой директории — недопустимая операция так,
как корень — высший уровень в иерархии.
```
> Пример 3:
```text
Ввод: path = "/home//foo/"
Выход: "/home/foo"
Объяснение: В каноническом пути, множественные последовательные слеши заменяются на единственный.
```


## Django 
1. Автоматически сгенерированная миграция БД, представленная ниже, изменяет модель `Question` — переименование поля с `answer` на `answer_list`, а также смена типа этого поля с `ForeignKey` на `ManyToManyField`. Внести изменения в файл миграции так, чтобы вместе с изменениями в структуре таблицы, был осуществлен перенос значений из старого поля — в новое.

```python
# Generated by Django 4.1.3 on <...>

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('quiz', '0001_initial'),
    ]

    operations = [
        migrations.RemoveField(
            model_name='question',
            name='answer',
        ),
        migrations.AddField(
            model_name='question',
            name='answer_list',
            field=models.ManyToManyField(
                help_text='This is a list of answers.',
                to='quiz.answer',
                verbose_name='answer list'
            ),
        ),
    ]

```

2. Ниже приведены модели `Room` — помещения, `Chair` — стулья и `Table` — столы. Стулья бывают 3-х типов (`BENCH`, `DINING`, `ARMCHAIR` — в поле `Chair.type`), у столов — разное количество посадочных мест (поле `Table.seats`). И столы и стулья могут быть закреплены за каким-либо помещением (поля `Chair.placed_at` и `Table.placed_at` соответственно). 
Измените функцию `get_rooms_with_missing_seats`, агрументами которой являются типы стульев `chair_types`, чтобы её ответом стал набор (`QuerySet`) помещений, в которых суммарное количество посадочных мест столов меньше чем количество стульев тех типов, которые были переданы функцию.

```python
from django.db import models


class Room(models.Model):
    name = models.CharField(32)


class ChairTypeEnum(models.TextChoices):
    BENCH = 'B', 'Bench chair'
    DINING = 'D', 'Dining chair'
    ARMCHAIR = 'A', 'Armchair'


class Chair(models.Model):
    stock_keeping_unit = models.CharField(200, pk=True)
    type = models.CharField(1, choises=ChairTypeEnum.choices, null=False, blank=False)
    placed_at = models.ForeignKey(Room,  models.SET_NULL, related_name='chairs',)


class Table(models.Model):
    stock_keeping_unit = models.CharField(200, pk=True)
    seats = models.PositiveSmallIntegerField(null=False, blank=False)
    placed_at = models.ForeignKey(Room,  models.SET_NULL,  related_name='tables')


def get_rooms_with_missing_seats(*chair_types: ChairTypeEnum) -> models.QuerySet:
    # <код функции>
    ...

```

3. Написать SQL-запрос которым можно будет получить такой же ответ, что и от функции `get_rooms_with_missing_seats` в Вашем решении задания 2.